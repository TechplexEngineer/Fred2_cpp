// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Drive.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/oi_HDrive.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include <math.h>
#include "U.h"

Drive::Drive() : Subsystem("Drive") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	leftFront = RobotMap::driveLeftFront;
	leftRear = RobotMap::driveLeftRear;
	rightFront = RobotMap::driveRightFront;
	rightRear = RobotMap::driveRightRear;
	drivetrain = RobotMap::driveDrivetrain;
	strafe = RobotMap::driveStrafe;
	gyro = RobotMap::drivegyro;
	leftEncoder = RobotMap::driveLeftEncoder;
	rightEncoder = RobotMap::driveRightEncoder;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	gyro->SetSensitivity(voltsPerDegreePerSecond);
	SmartDashboard::PutNumber("straight kp", .03);

	serial_port = new SerialPort(57600,SerialPort::kMXP);
	uint8_t update_rate_hz = 50;

	imu = new AHRS(serial_port,update_rate_hz);

}

void Drive::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new oi_HDrive());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void Drive::HDrive(double moveValue, double turnValue, double strafeValue) {
	drivetrain->ArcadeDrive(-moveValue, -turnValue);
	strafe->Set(strafeValue);
}
void Drive::stop(){
	drivetrain->ArcadeDrive(0.0, 0.0);
	strafe->Set(0);
}

//when the robot resets clear the gyro error
void Drive::resetGyro() {
	// System.out.println("Resetting Gyro");
	gyro->Reset();
	if(imu != NULL){
		imu->ZeroYaw();
	}
	prevTurn = 0;
	targetHeading = 0;
	error = 0;
}


//Hdrive with strafe gyro compensation
void Drive::hDrive(double drive, double turn, double slide){
	HDrive(drive, turn, slide);
	return;
}


void Drive::driveStraight(double speed) {
	ds_kp = SmartDashboard::GetNumber("straight kp");
	double angle = getGyroAngle(); // get current heading
	double output = -angle*Kp;
	
	output = U::constrain(-1, output, 1);
	if (abs(output) < .4 && output != 0) {
		output = (output/abs(output))*.4;
	}
	HDrive(speed, output, 0.0);
}

double Drive::leftDistance() {
	return leftEncoder->GetDistance();
}
double Drive::rightDistance() {
	return rightEncoder->GetDistance();
}

void Drive::resetLeftDistance() {
	leftEncoder->Reset();
}
void Drive::ResetRightDistance() {
	rightEncoder->Reset();
}

//we'll backup the NavX with the analog Gyro
double Drive::getGyroAngle()
{
	if (imu->IsConnected() && !imu->IsCalibrating())
	{
		return imu->GetYaw();
	}
	return gyro->GetAngle();
}
double Drive::getOldGyroAngle() {
	return 0; //gyro.getAngle();
}

double Drive::getDegreesFromEncoderValues()
{
	const double trackwidth = 24;

	double robotArcLength = (leftDistance()-rightDistance())/2;
	double robotDegrees = 360*(robotArcLength/(M_PI*trackwidth));

	return robotDegrees;
}
